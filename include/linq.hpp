///
/// linq, a header-only LINQ library for C++.
/// version: 0.9.0
///
/// Copyright (c) 2015-2025 Cemalettin Dervis
/// https://dervis.de/linq
///
/// Licensed under the:
///
/// Boost Software License - Version 1.0 - August 17th, 2003
///
/// Permission is hereby granted, free of charge, to any person or organization
/// obtaining a copy of the software and accompanying documentation covered by
/// this license (the "Software") to use, reproduce, display, distribute,
/// execute, and transmit the Software, and to prepare derivative works of the
/// Software, and to permit third-parties to whom the Software is furnished to
/// do so, all subject to the following:
///
/// The copyright notices in the Software and this entire statement, including
/// the above license grant, this restriction and the following disclaimer,
/// must be included in all copies of the Software, in whole or in part, and
/// all derivative works of the Software, unless such copies or derivative
/// works are solely in the form of machine-executable object code generated by
/// a source language processor.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
/// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
/// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

#ifndef LINQ_HPP_INCLUDED
#define LINQ_HPP_INCLUDED

#include <algorithm>
#include <charconv>
#include <functional>
#include <initializer_list>
#include <optional>
#include <type_traits>

// clang-format off

#if !defined( LINQ_NO_ASSERTIONS ) && !defined( LINQ_ASSERT )
#  include <cassert>
#  define LINQ_ASSERT( ... ) assert( __VA_ARGS__ )
#else
#  define LINQ_ASSERT( ... ) (void)( __VA_ARGS__ )
#endif

#ifndef LINQ_NO_STL_CONTAINERS
#  include <array>
#  include <list>
#  include <map>
#  include <set>
#  include <unordered_map>
#  include <unordered_set>
#  include <vector>
#  ifdef __cpp_lib_flat_map
#    include <flat_map>
#  endif
#  ifdef __cpp_lib_flat_set
#    include <flat_set>
#  endif
#endif

#ifndef LINQ_TO_STRING_FUNC
#  include <string>
#  define LINQ_TO_STRING_FUNC std::to_string
#endif

#ifdef __cpp_lib_concepts
#  include <concepts>
#endif

// clang-format on

namespace linq {
/// Defines a direction for sorting ranges.
enum class sort_direction {
    /// Sort elements in ascending order.
    ascending,

    /// Sort elements in descending order.
    descending
};

namespace details {
// ----------------------------------
// Range declaration
// ----------------------------------

template <typename TPrevRange, typename TPredicate>
class where_range;

template <typename TPrevRange>
class distinct_range;

template <typename TPrevRange, typename TTransform>
class select_range;

template <typename TPrevRange, typename StringType>
class select_to_string_range;

template <typename TPrevRange, typename TTransform>
class select_many_range;

template <typename TPrevRange>
class reverse_range;

template <typename TPrevRange>
class take_range;

template <typename TPrevRange, typename TPredicate>
class take_while_range;

template <typename TPrevRange>
class skip_range;

template <typename TPrevRange, typename TPredicate>
class skip_while_range;

template <typename TPrevRange, typename TOtherRange>
class append_range;

template <typename TPrevRange>
class repeat_range;

template <
    typename TPrevRange,
    typename TOtherRange,
    typename TKeySelectorA,
    typename TKeySelectorB,
    typename TTransform>
class join_range;

template <typename TPrevRange, typename TKeySelector>
class order_by_range;

template <typename TPrevRange, typename TKeySelector>
class then_by_range;

// ----------------------------------
// Average calculators
// ----------------------------------

#ifdef __cpp_lib_concepts
template <typename T>
concept number = std::integral<T> || std::floating_point<T>;

template <typename T>
concept averageable = requires( T a, T b, size_t c ) {
    requires std::is_default_constructible_v<T>;
    { a / c } -> std::same_as<T>;
    a += b;
} || number<T>;

template <typename T>
concept addable = requires( T a, T b ) {
    { a += b } -> std::convertible_to<T>;
    { a < b } -> std::same_as<bool>;
} || number<T>;

template <typename T>
concept has_fixed_size = requires( T t ) {
    { t.size() } -> std::same_as<size_t>;
};

template <typename T>
concept has_first_and_second_type = requires {
    typename T::first_type;
    typename T::second_type;
};
#endif

template <typename T, typename TRange>
#ifdef __cpp_lib_concepts
    requires( averageable<T> )
#endif
static constexpr auto calculate_average( const TRange& op ) {
    using float_type = long double;
    using output_t   = typename TRange::output_t;

#ifdef __cpp_lib_concepts
    using return_t = std::conditional_t<number<output_t>, float_type, output_t>;
#else
    using return_t = std::
        conditional_t<std::is_integral<output_t>::value || std::is_floating_point_v<output_t>, float_type, output_t>;
#endif

    if ( const auto maybe_sum_and_count = op.sum_and_count() ) {
        const auto& sum_and_count = *maybe_sum_and_count;
        return std::optional<return_t>( static_cast<return_t>( sum_and_count.first ) / sum_and_count.second );
    }

    return std::optional<return_t>();
}

// ----------------------------------
// base_range
// ----------------------------------

/// Base class to identify all range types (for compile-time type checking).
class range_ident {
    // Nothing to define here.
};

/// Base class for sorting ranges (for compile-time type checking).
class sorting_range {
    // Nothing to define here.
};

template <typename Range>
static constexpr auto get_range_size( const Range& range ) -> size_t
    requires( has_fixed_size<Range> )
{
    return range.size();
}

/// @brief Represents the base class of all linq ranges.
/// @tparam TOutput The full, unmodified type that is returned by the range.
template <typename Derived, typename TOutput>
class range : public range_ident {
  public:
    /// Return non-const, non-volatile, non-reference types from methods such as sum, min and max.
    using output_t = std::decay_t<TOutput>;

    /// @brief Appends a filter to the range.
    /// @tparam TPredicate The type of the predicate: f(x) -> bool
    /// @param predicate The predicate
    /// @return A new range that combines this range with the where-range
    template <typename TPredicate>
    [[nodiscard]]
    constexpr auto where( TPredicate&& predicate ) const;

    /// @brief Appends a distinct-filter to the range that removes duplicate elements.
    /// @return A new range that combines this range with the distinct-range
    [[nodiscard]]
    constexpr auto distinct() const;

    template <typename TTransform>
    [[nodiscard]]
    constexpr auto select( TTransform&& transform ) const;

#ifdef LINQ_NO_STL_CONTAINERS
    template <typename StringType>
#endif
    [[nodiscard]]
    constexpr auto
    select_to_string( int int_base = 10, std::chars_format float_format = std::chars_format::general ) const;

    template <typename TTransform>
    [[nodiscard]]
    constexpr auto select_many( TTransform&& transform ) const;

    [[nodiscard]]
    constexpr auto reverse() const;

    [[nodiscard]]
    constexpr auto take( size_t count ) const;

    template <typename TPredicate>
    [[nodiscard]]
    constexpr auto take_while( TPredicate&& predicate ) const;

    [[nodiscard]]
    constexpr auto skip( size_t count ) const;

    template <typename TPredicate>
    [[nodiscard]]
    constexpr auto skip_while( TPredicate&& predicate ) const;

    template <typename TOtherRange>
    [[nodiscard]]
    constexpr auto append( const TOtherRange& other_range ) const;

    [[nodiscard]]
    constexpr auto repeat( size_t count ) const;

    template <typename TOtherRange, typename TKeySelectorA, typename TKeySelectorB, typename TTransform>
    [[nodiscard]]
    constexpr auto join(
        const TOtherRange& other_range,
        TKeySelectorA&&    key_selector_a,
        TKeySelectorB&&    key_selector_b,
        TTransform&&       transform ) const;

    template <typename TKeySelector>
    [[nodiscard]]
    constexpr auto order_by( TKeySelector&& key_selector, sort_direction sort_dir ) const;

    template <typename TKeySelector>
    [[nodiscard]]
    constexpr auto order_by_ascending( TKeySelector&& key_selector ) const;

    template <typename TKeySelector>
    [[nodiscard]]
    constexpr auto order_by_descending( TKeySelector&& key_selector ) const;

    template <typename TKeySelector>
    [[nodiscard]]
    constexpr auto then_by( TKeySelector&& key_selector, sort_direction sort_dir ) const;

    template <typename TKeySelector>
    [[nodiscard]]
    constexpr auto then_by_ascending( TKeySelector&& key_selector ) const;

    template <typename TKeySelector>
    [[nodiscard]]
    constexpr auto then_by_descending( TKeySelector&& key_selector ) const;

    [[nodiscard]]
    constexpr auto sum() const;

    [[nodiscard]]
    constexpr auto min() const;

    [[nodiscard]]
    constexpr auto max() const;

    [[nodiscard]]
    constexpr auto sum_and_count() const;

    [[nodiscard]]
    constexpr auto average() const
#ifdef __cpp_lib_concepts
        requires( averageable<output_t> )
#endif
    ;

#ifdef __cpp_lib_concepts
    template <typename TSeed, std::invocable<TSeed&&, const TOutput&> TAccumFunc>
#else
    template <typename TSeed, typename TAccumFunc>
#endif
    [[nodiscard]]
    constexpr auto aggregate( TSeed seed, TAccumFunc&& func ) const;

#ifdef __cpp_lib_concepts
    template <std::invocable<TOutput&&, const TOutput&> TAccumFunc>
#else
    template <typename TAccumFunc>
#endif
    [[nodiscard]]
    constexpr auto reduce( const TAccumFunc& func ) const;

    [[nodiscard]]
    constexpr auto first() const -> std::optional<output_t>;

    template <typename TPredicate>
    [[nodiscard]]
    constexpr auto first( const TPredicate& predicate ) const -> std::optional<output_t>;

    [[nodiscard]]
    constexpr auto last() const -> std::optional<output_t>;

    template <typename TPredicate>
    [[nodiscard]]
    constexpr auto last( const TPredicate& predicate ) const -> std::optional<output_t>;

    template <typename TPredicate>
    [[nodiscard]]
    constexpr auto any( const TPredicate& predicate ) const -> bool;

    template <typename TPredicate>
    [[nodiscard]]
    constexpr auto all( const TPredicate& predicate ) const -> bool;

    template <typename TPredicate>
    [[nodiscard]]
    constexpr auto none( const TPredicate& predicate ) const -> bool;

    [[nodiscard]]
    constexpr auto count() const -> size_t;

    template <typename TPredicate>
    [[nodiscard]]
    constexpr auto count( const TPredicate& predicate ) const -> size_t;

    [[nodiscard]]
    constexpr auto element_at( size_t index ) const -> std::optional<output_t>;

    template <typename U>
    constexpr auto equals( const range<U, TOutput>& other_range ) const -> bool;

    constexpr auto equals( const std::initializer_list<TOutput>& list ) const -> bool;

#ifndef LINQ_NO_STL_CONTAINERS

    [[nodiscard]]
    auto to_vector() const -> std::vector<output_t>;

    [[nodiscard]]
    auto to_map() const
#ifdef __cpp_lib_concepts
        requires( has_first_and_second_type<output_t> )
#endif
    ;

    [[nodiscard]]
    auto to_unordered_map() const
#ifdef __cpp_lib_concepts
        requires( has_first_and_second_type<output_t> )
#endif
    ;

#endif // LINQ_NO_STL_CONTAINERS

  private:
    constexpr auto self_ref() {
        return static_cast<Derived&>( *this );
    }

    constexpr auto self_ref() const {
        return static_cast<const Derived&>( *this );
    }
};

// ----------------------------------
// where
// ----------------------------------

template <typename TPrevRange, typename TPredicate>
class where_range final : public range<where_range<TPrevRange, TPredicate>, typename TPrevRange::iterator::output_t> {
  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = typename prev_iter_t::output_t;

        constexpr iterator( const where_range* parent, prev_iter_t begin, prev_iter_t end )
            : m_parent( parent )
            , m_begin( begin )
            , m_end( end ) {
            const auto& pred = m_parent->m_predicate;

            // Seek the first match.
            while ( m_begin != m_end && !std::invoke( pred, *m_begin ) )
                ++m_begin;
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_begin == o.m_begin;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_begin != o.m_begin;
        }

        constexpr iterator& operator++() {
            const auto& pred = m_parent->m_predicate;

            do {
                ++m_begin;
            } while ( m_begin != m_end && !std::invoke( pred, *m_begin ) );

            return *this;
        }

        constexpr auto operator*() const -> const output_t& {
            return *m_begin;
        }

        const where_range* m_parent;
        prev_iter_t        m_begin;
        prev_iter_t        m_end;
    };

    constexpr where_range() = default;

    constexpr where_range( const TPrevRange& prev, TPredicate predicate )
        : m_prev( prev )
        , m_predicate( std::move( predicate ) ) {
    }

    constexpr auto begin() const -> iterator {
        return iterator( this, m_prev.begin(), m_prev.end() );
    }

    constexpr auto end() const -> iterator {
        const auto prev_end = m_prev.end();
        return iterator( this, prev_end, prev_end );
    }

  private:
    TPrevRange m_prev;
    TPredicate m_predicate;
};

// ----------------------------------
// distinct
// ----------------------------------

template <typename TPrevRange>
class distinct_range final : public range<distinct_range<TPrevRange>, typename TPrevRange::iterator::output_t> {
    using prev_iter_t      = typename TPrevRange::iterator;
    using object_container = std::vector<prev_iter_t>;

  public:
    struct iterator {
        using output_t = typename prev_iter_t::output_t;

        constexpr iterator( prev_iter_t begin, prev_iter_t end, object_container* encountered_objects )
            : m_begin( begin )
            , m_end( end )
            , m_encountered_objects( encountered_objects ) {
            if ( m_begin != m_end ) {
                encountered_objects->clear();
                encountered_objects->push_back( m_begin );
            }
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_begin == o.m_begin;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_begin != o.m_begin;
        }

        constexpr iterator& operator++() {
            do {
                ++m_begin;
            } while ( m_begin != m_end && contains_object( m_begin ) );

            if ( m_begin != m_end )
                m_encountered_objects->push_back( m_begin );

            return *this;
        }

        constexpr bool contains_object( const prev_iter_t& it ) {
            const auto& it_val = *it;

            const auto&  encountered_objects = *m_encountered_objects;
            const size_t size                = encountered_objects.size();

            for ( size_t i = 0; i < size; ++i ) {
                if ( *encountered_objects[i] == it_val )
                    return true;
            }

            return false;
        }

        constexpr const output_t& operator*() const {
            return *m_begin;
        }

        prev_iter_t       m_begin;
        prev_iter_t       m_end;
        object_container* m_encountered_objects;
    };

    constexpr distinct_range() = default;

    constexpr explicit distinct_range( const TPrevRange& prev )
        : m_prev( prev ) {
    }

    constexpr iterator begin() const {
        return iterator{ m_prev.begin(), m_prev.end(), std::addressof( m_encountered_objects ) };
    }

    constexpr iterator end() const {
        const auto prev_end = m_prev.end();
        return iterator{ prev_end, prev_end, std::addressof( m_encountered_objects ) };
    }

  private:
    TPrevRange               m_prev;
    mutable object_container m_encountered_objects;
};

// ----------------------------------
// select
// ----------------------------------

// Resolves the arguments that are passed to a select functor.
template <typename TPrevRange>
using select_transform_arg_t = std::add_const_t<std::add_lvalue_reference_t<typename TPrevRange::iterator::output_t>>;

// Resolves the return type of a select functor.
template <typename TPrevRange, typename TTransform>
using select_output_t = std::invoke_result_t<TTransform, select_transform_arg_t<TPrevRange>>;

template <typename TPrevRange, typename TTransform>
class select_range final : public range<select_range<TPrevRange, TTransform>, select_output_t<TPrevRange, TTransform>> {
  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = select_output_t<TPrevRange, TTransform>;

        constexpr iterator( const select_range* parent, prev_iter_t begin, prev_iter_t end )
            : m_parent( parent )
            , m_begin( begin )
            , m_end( end ) {
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_begin == o.m_begin;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_begin != o.m_begin;
        }

        constexpr iterator& operator++() {
            ++m_begin;
            return *this;
        }

        constexpr output_t operator*() const {
            return m_parent->m_transform( *m_begin );
        }

        const select_range* m_parent;
        prev_iter_t         m_begin;
        prev_iter_t         m_end;
    };

    constexpr select_range( const TPrevRange& prev, TTransform transform )
        : m_prev( prev )
        , m_transform( std::move( transform ) ) {
    }

    constexpr auto begin() const -> iterator {
        return iterator( this, m_prev.begin(), m_prev.end() );
    }

    constexpr auto end() const -> iterator {
        const auto prev_end = m_prev.end();
        return iterator( this, prev_end, prev_end );
    }

    constexpr auto size() const -> size_t {
        return m_prev.size();
    }

  private:
    TPrevRange m_prev;
    TTransform m_transform{};
};

// ----------------------------------
// select_to_string
// ----------------------------------

template <typename TPrevRange, typename StringType>
class select_to_string_range final : public range<select_to_string_range<TPrevRange, StringType>, StringType> {
  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = StringType;

        constexpr iterator( const select_to_string_range* parent, prev_iter_t begin, prev_iter_t end )
            : m_parent( parent )
            , m_begin( begin )
            , m_end( end ) {
        }

        constexpr auto operator==( const iterator& o ) const -> bool {
            return m_begin == o.m_begin;
        }

        constexpr auto operator!=( const iterator& o ) const -> bool {
            return m_begin != o.m_begin;
        }

        constexpr auto operator++() -> iterator& {
            ++m_begin;
            return *this;
        }

#if 0
#ifdef __cpp_lib_constexpr_charconv
        constexpr
#endif
                auto
                operator*() const -> output_t requires(number<typename TPrevRange::output_t>) {
                    constexpr auto buffer_size = static_cast<size_t>(32);
                    char buffer[buffer_size]{};

                    const auto result = [&]() -> std::to_chars_result {
                        if constexpr (std::is_integral_v<typename TPrevRange::output_t>) {
                            return std::to_chars(buffer, &buffer[buffer_size], *m_begin, m_parent->m_int_base);
                        }

                        return std::to_chars(buffer, &buffer[buffer_size], *m_begin, m_parent->m_float_format);
                    }();

                    if (result.ec == std::errc()) {
                        const auto char_count = static_cast<size_t>(result.ptr - buffer);
                        return StringType(buffer, char_count);
                    }

                    return StringType("?");
                }
#endif

        auto operator*() const -> output_t
            requires( std::is_same_v<typename TPrevRange::output_t, char> )
        {
            return StringType( 1, *m_begin );
        }

        auto operator*() const -> output_t {
            return LINQ_TO_STRING_FUNC( *m_begin );
        }

        const select_to_string_range* m_parent{};
        prev_iter_t                   m_begin;
        prev_iter_t                   m_end;
    };

    constexpr explicit select_to_string_range(
        const TPrevRange&       prev,
        const int               int_base,
        const std::chars_format float_format )
        : m_prev( prev )
        , m_int_base( int_base )
        , m_float_format( float_format ) {
    }

    constexpr auto begin() const -> iterator {
        return iterator( this, m_prev.begin(), m_prev.end() );
    }

    constexpr auto end() const -> iterator {
        const auto prev_end = m_prev.end();
        return iterator( this, prev_end, prev_end );
    }

    constexpr auto size() const -> size_t {
        return m_prev.size();
    }

  private:
    TPrevRange        m_prev;
    int               m_int_base;
    std::chars_format m_float_format;
};

// ----------------------------------
// select_many
// ----------------------------------

template <typename TPrevRange, typename TTransform>
struct select_many_traits {
    using returned_range_t = std::invoke_result_t<TTransform, typename TPrevRange::iterator::output_t>;

    // See if the returned type is really a range.
    static_assert(
        std::is_base_of_v<range_ident, returned_range_t>,
        "The transform function of select_many is expected to return a linq range." );

    using output_t = typename returned_range_t::iterator::output_t;
};

template <typename TPrevRange, typename TTransform>
class select_many_range final : public range<
                                    select_many_range<TPrevRange, TTransform>,
                                    typename select_many_traits<TPrevRange, TTransform>::output_t> {
  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;

        using returned_range_t      = typename select_many_traits<TPrevRange, TTransform>::returned_range_t;
        using returned_range_iter_t = typename returned_range_t::iterator;
        using output_t              = typename returned_range_iter_t::output_t;

        constexpr iterator( const select_many_range* parent, prev_iter_t pos, prev_iter_t end )
            : m_parent( parent )
            , m_pos( std::move( pos ) )
            , m_end( std::move( end ) ) {
            if ( m_pos != m_end ) {
                const auto& transform = m_parent->m_transform;
                bool        first     = true;

                do {
                    if ( !first ) {
                        ++m_pos;
                    }

                    if ( m_pos == m_end ) {
                        break;
                    }

                    m_ret_range = std::invoke( transform, *m_pos );
                    m_ret_begin = m_ret_range.begin();
                    m_ret_end   = m_ret_range.end();

                    first = false;
                } while ( m_ret_begin == m_ret_end );
            }
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_pos == o.m_pos;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_pos != o.m_pos;
        }

        constexpr iterator& operator++() {
            if ( m_ret_begin != m_ret_end ) {
                // There are values left to be obtained from the returned range.
                ++m_ret_begin;
            }

            if ( m_ret_begin == m_ret_end ) {
                // Move our parent iterator forward to get the next container.
                ++m_pos;

                if ( m_pos != m_end ) {
                    m_ret_range = m_parent->m_transform( *m_pos );
                    m_ret_begin = m_ret_range.begin();
                    m_ret_end   = m_ret_range.end();
                }
            }

            return *this;
        }

        constexpr const output_t& operator*() const {
            return *m_ret_begin;
        }

        const select_many_range* m_parent;
        prev_iter_t              m_pos;
        prev_iter_t              m_end;

        returned_range_t      m_ret_range;
        returned_range_iter_t m_ret_begin;
        returned_range_iter_t m_ret_end;
    };

    constexpr select_many_range() = default;

    constexpr select_many_range( const TPrevRange& prev, TTransform transform )
        : m_prev( prev )
        , m_transform( std::move( transform ) ) {
    }

    constexpr iterator begin() const {
        return iterator{ this, m_prev.begin(), m_prev.end() };
    }

    constexpr iterator end() const {
        const auto prev_end = m_prev.end();
        return iterator{ this, prev_end, prev_end };
    }

  private:
    TPrevRange m_prev;
    TTransform m_transform;
};

// ----------------------------------
// reverse
// ----------------------------------

template <typename TPrevRange>
class reverse_range final : public range<reverse_range<TPrevRange>, typename TPrevRange::iterator::output_t> {
  public:
    using prev_iter_t      = typename TPrevRange::iterator;
    using object_container = std::vector<prev_iter_t>;

    struct iterator {
        using output_t = typename prev_iter_t::output_t;

        constexpr iterator( const object_container* prev_iterators, size_t index )
            : m_prev_iterators( prev_iterators )
            , m_index( index ) {
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_index == o.m_index;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_index != o.m_index;
        }

        constexpr iterator& operator++() {
            --m_index;
            return *this;
        }

        constexpr const output_t& operator*() const {
            return *( *m_prev_iterators )[m_index];
        }

        const object_container* m_prev_iterators;
        size_t                  m_index{};
    };

    constexpr reverse_range() = default;

    constexpr explicit reverse_range( const TPrevRange& prev )
        : m_prev( prev ) {
    }

    constexpr iterator begin() const {
        m_prev_iterators.clear();

        for ( auto beg = m_prev.begin(), end = m_prev.end(); beg != end; ++beg ) {
            m_prev_iterators.push_back( beg );
        }

        return iterator{ std::addressof( m_prev_iterators ), m_prev_iterators.size() - 1 };
    }

    constexpr iterator end() const {
        return iterator{ nullptr, static_cast<size_t>( -1 ) };
    }

    constexpr auto size() const -> size_t {
        return m_prev.size();
    }

  private:
    TPrevRange               m_prev;
    mutable object_container m_prev_iterators;
};

// ----------------------------------
// take
// ----------------------------------

template <typename TPrevRange>
class take_range final : public range<take_range<TPrevRange>, typename TPrevRange::iterator::output_t> {
  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = typename prev_iter_t::output_t;

        constexpr iterator( prev_iter_t begin, size_t count )
            : m_begin( begin )
            , m_count( count ) {
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_count == o.m_count || m_begin == o.m_begin;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_count != o.m_count && m_begin != o.m_begin;
        }

        constexpr iterator& operator++() {
            ++m_begin;
            --m_count;
            return *this;
        }

        constexpr const output_t& operator*() const {
            return *m_begin;
        }

        prev_iter_t m_begin;
        size_t      m_count{};
    };

    constexpr take_range() = default;

    constexpr take_range( const TPrevRange& prev, size_t count )
        : m_prev( prev )
        , m_count( count ) {
    }

    constexpr iterator begin() const {
        return iterator( m_prev.begin(), m_count );
    }

    constexpr iterator end() const {
        return iterator( m_prev.end(), 0 );
    }

    constexpr auto size() const -> size_t {
        return m_count;
    }

  private:
    TPrevRange m_prev;
    size_t     m_count{};
};

// ----------------------------------
// take_while
// ----------------------------------

template <typename TPrevRange, typename TPredicate>
class take_while_range final
    : public range<take_while_range<TPrevRange, TPredicate>, typename TPrevRange::iterator::output_t> {
  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = typename prev_iter_t::output_t;

        constexpr iterator( const take_while_range* parent, prev_iter_t begin, prev_iter_t end )
            : m_parent( parent )
            , m_begin( begin )
            , m_end( end ) {
            const auto& pred = m_parent->m_predicate;

            if ( m_begin != m_end && !std::invoke( pred, *m_begin ) )
                m_begin = m_end;
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_begin == o.m_begin;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_begin != o.m_begin;
        }

        constexpr iterator& operator++() {
            ++m_begin;

            const auto& pred = m_parent->m_predicate;

            if ( m_begin != m_end && !std::invoke( pred, *m_begin ) )
                m_begin = m_end;

            return *this;
        }

        constexpr const output_t& operator*() const {
            return *m_begin;
        }

        const take_while_range* m_parent;
        prev_iter_t             m_begin;
        prev_iter_t             m_end;
    };

    constexpr take_while_range() = default;

    constexpr take_while_range( const TPrevRange& prev, TPredicate predicate )
        : m_prev( prev )
        , m_predicate( std::move( predicate ) ) {
    }

    constexpr iterator begin() const {
        return iterator( this, m_prev.begin(), m_prev.end() );
    }

    constexpr iterator end() const {
        return iterator( this, m_prev.end(), m_prev.end() );
    }

  private:
    TPrevRange m_prev;
    TPredicate m_predicate;
};

// ----------------------------------
// skip
// ----------------------------------

template <typename TPrevRange>
class skip_range final : public range<skip_range<TPrevRange>, typename TPrevRange::iterator::output_t> {
  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = typename prev_iter_t::output_t;

        constexpr iterator( prev_iter_t begin, prev_iter_t end, size_t count )
            : m_begin( begin ) {
            while ( m_begin != end && count > 0 ) {
                ++m_begin;
                --count;
            }
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_begin == o.m_begin;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_begin != o.m_begin;
        }

        constexpr iterator& operator++() {
            ++m_begin;
            return *this;
        }

        constexpr const output_t& operator*() const {
            return *m_begin;
        }

        prev_iter_t m_begin;
    };

    constexpr skip_range( const TPrevRange& prev, size_t count )
        : m_prev( prev )
        , m_count( count ) {
    }

    constexpr iterator begin() const {
        return iterator( m_prev.begin(), m_prev.end(), m_count );
    }

    constexpr iterator end() const {
        const auto prev_end = m_prev.end();
        return iterator( prev_end, prev_end, 0 );
    }

  private:
    TPrevRange m_prev;
    size_t     m_count{};
};

// ----------------------------------
// skip_while
// ----------------------------------

template <typename TPrevRange, typename TPredicate>
class skip_while_range final
    : public range<skip_while_range<TPrevRange, TPredicate>, typename TPrevRange::iterator::output_t> {
  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = typename prev_iter_t::output_t;

        constexpr iterator( prev_iter_t begin, prev_iter_t end, const TPredicate& predicate )
            : m_begin( begin ) {
            while ( m_begin != end && std::invoke( predicate, *m_begin ) ) {
                ++m_begin;
            }
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_begin == o.m_begin;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_begin != o.m_begin;
        }

        constexpr iterator& operator++() {
            ++m_begin;
            return *this;
        }

        constexpr const output_t& operator*() const {
            return *m_begin;
        }

        prev_iter_t m_begin;
    };

    constexpr skip_while_range( const TPrevRange& prev, const TPredicate& predicate )
        : m_prev( prev )
        , m_predicate( &predicate ) {
    }

    constexpr iterator begin() const {
        return iterator( m_prev.begin(), m_prev.end(), *m_predicate );
    }

    constexpr iterator end() const {
        const auto prev_end = m_prev.end();
        return iterator( prev_end, prev_end, *m_predicate );
    }

  private:
    TPrevRange        m_prev;
    const TPredicate* m_predicate{};
};

// ----------------------------------
// append
// ----------------------------------

template <typename TPrevRange, typename TOtherRange>
class append_range final
    : public range<append_range<TPrevRange, TOtherRange>, typename TPrevRange::iterator::output_t> {
  public:
    using other_range_iter_t = typename TOtherRange::iterator;

    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = typename prev_iter_t::output_t;

        constexpr iterator(
            prev_iter_t        begin,
            prev_iter_t        end,
            other_range_iter_t other_begin,
            other_range_iter_t other_end )
            : m_my_begin( begin )
            , m_my_end( end )
            , m_other_begin( other_begin )
            , m_other_end( other_end ) {
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_other_begin == o.m_other_begin;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_other_begin != o.m_other_begin;
        }

        constexpr iterator& operator++() {
            if ( m_my_begin != m_my_end )
                ++m_my_begin;
            else
                ++m_other_begin;

            return *this;
        }

        constexpr const output_t& operator*() const {
            return m_my_begin != m_my_end ? *m_my_begin : *m_other_begin;
        }

        prev_iter_t        m_my_begin;
        prev_iter_t        m_my_end;
        other_range_iter_t m_other_begin;
        other_range_iter_t m_other_end;
    };

    constexpr append_range( const TPrevRange& prev, const TOtherRange& other_range )
        : m_prev( prev )
        , m_other_range( other_range ) {
    }

    constexpr iterator begin() const {
        return iterator( m_prev.begin(), m_prev.end(), m_other_range.begin(), m_other_range.end() );
    }

    constexpr iterator end() const {
        const auto prev_end  = m_prev.end();
        const auto other_end = m_other_range.end();
        return iterator( prev_end, prev_end, other_end, other_end );
    }

  private:
    TPrevRange  m_prev;
    TOtherRange m_other_range;
};

// ----------------------------------
// repeat
// ----------------------------------

template <typename TPrevRange>
class repeat_range final : public range<repeat_range<TPrevRange>, typename TPrevRange::iterator::output_t> {
  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = typename prev_iter_t::output_t;

        constexpr iterator( TPrevRange* prev_range_ptr, prev_iter_t begin, prev_iter_t end, size_t count )
            : m_prev_range_ptr( prev_range_ptr )
            , m_pos( begin )
            , m_end( end )
            , m_count( count ) {
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_pos == o.m_pos;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_pos != o.m_pos;
        }

        constexpr iterator& operator++() {
            ++m_pos;

            if ( m_pos == m_end && m_count > 0 ) {
                m_pos = m_prev_range_ptr->begin();
                --m_count;
            }

            return *this;
        }

        constexpr const output_t& operator*() const {
            return *m_pos;
        }

        TPrevRange* m_prev_range_ptr{};
        prev_iter_t m_pos{};
        prev_iter_t m_end{};
        size_t      m_count{};
    };

    constexpr repeat_range( const TPrevRange& prev, size_t count )
        : m_prev( prev )
        , m_count( count ) {
    }

    constexpr iterator begin() const {
        return iterator( &m_prev, m_prev.begin(), m_prev.end(), m_count );
    }

    constexpr iterator end() const {
        const auto prev_end = m_prev.end();
        return iterator( &m_prev, prev_end, prev_end, 0 );
    }

  private:
    mutable TPrevRange m_prev;
    size_t             m_count;
};

// ----------------------------------
// join
// ----------------------------------

// Determines the output of a selection in the join range.
template <typename TRangeA, typename TRangeB, typename TTransform>
using join_output_t =
    std::invoke_result_t<TTransform, typename TRangeA::iterator::output_t, typename TRangeB::iterator::output_t>;

// Nested loop inner join operator.
template <
    typename TPrevRange,
    typename TOtherRange,
    typename TKeySelectorA,
    typename TKeySelectorB,
    typename TTransform>
class join_range final : public range<
                             join_range<TPrevRange, TOtherRange, TKeySelectorA, TKeySelectorB, TTransform>,
                             join_output_t<TPrevRange, TOtherRange, TTransform>> {
    using other_range_iter_t = typename TOtherRange::iterator;

  public:
    struct iterator {
        using prev_iter_t = typename TPrevRange::iterator;
        using output_t    = join_output_t<TPrevRange, TOtherRange, TTransform>;

        constexpr iterator( prev_iter_t begin, prev_iter_t end, const join_range* parent )
            : m_begin( begin )
            , m_end( end )
            , m_pos( begin )
            , m_other_begin( parent->m_other_range.begin() )
            , m_other_end( parent->m_other_range.end() )
            , m_other_pos( parent->m_other_range.begin() )
            , m_parent( parent ) {
            // Find the first match without pre-incrementing the
            // other position, so that we start at the beginning.
            find_next( false );
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_pos == o.m_pos;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_pos != o.m_pos;
        }

        constexpr iterator& operator++() {
            // Find the next match, but pre-increment the other
            // position, so that we can move forward.
            find_next( true );
            return *this;
        }

        constexpr output_t operator*() const {
            return m_parent->m_transform( *m_pos, *m_other_pos );
        }

        prev_iter_t m_begin;
        prev_iter_t m_end;
        prev_iter_t m_pos;

        other_range_iter_t m_other_begin;
        other_range_iter_t m_other_end;
        other_range_iter_t m_other_pos;

        const join_range* m_parent;

      private:
        // Finds the next match in both ranges using the key selectors and == comparison.
        constexpr void find_next( bool pre_increment_other ) {
            const auto& key_selector_a = m_parent->m_key_selector_a;
            const auto& key_selector_b = m_parent->m_key_selector_b;

            if ( pre_increment_other ) {
                ++m_other_pos;
            }

            while ( m_pos != m_end ) {
                bool       should_continue = true;
                const auto key_a           = key_selector_a( *m_pos );

                while ( m_other_pos != m_other_end ) {
                    const auto key_b = key_selector_b( *m_other_pos );

                    if ( key_a == key_b ) {
                        should_continue = false;
                        break;
                    }

                    ++m_other_pos;
                }

                // Start over in the other range if it's finished.
                if ( m_other_pos == m_other_end )
                    m_other_pos = m_other_begin;

                if ( !should_continue ) {
                    break;
                }

                ++m_pos;
            }
        }
    };

    constexpr join_range(
        const TPrevRange& prev,
        TOtherRange       other_range,
        TKeySelectorA     key_selector_a,
        TKeySelectorB     key_selector_b,
        TTransform        transform )
        : m_prev( prev )
        , m_other_range( other_range )
        , m_key_selector_a( std::move( key_selector_a ) )
        , m_key_selector_b( std::move( key_selector_b ) )
        , m_transform( std::move( transform ) ) {
    }

    constexpr iterator begin() const {
        return iterator( m_prev.begin(), m_prev.end(), this );
    }

    constexpr iterator end() const {
        const auto prev_end = m_prev.end();
        return iterator( prev_end, prev_end, this );
    }

  private:
    TPrevRange    m_prev;
    TOtherRange   m_other_range;
    TKeySelectorA m_key_selector_a;
    TKeySelectorB m_key_selector_b;
    TTransform    m_transform;
};

// ----------------------------------
// order_by
// ----------------------------------

template <typename TPrevRange, typename TKeySelector>
class order_by_range final
    : public range<order_by_range<TPrevRange, TKeySelector>, typename TPrevRange::iterator::output_t>,
      public sorting_range {
  public:
    using container_element_t = std::decay_t<typename TPrevRange::iterator::output_t>;
    using container_t         = std::vector<container_element_t>;
    using container_iter_t    = typename container_t::const_iterator;

    struct iterator {
        using output_t = typename container_iter_t::reference;

        constexpr explicit iterator( container_iter_t pos )
            : m_pos( pos ) {
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_pos == o.m_pos;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_pos != o.m_pos;
        }

        constexpr iterator& operator++() {
            ++m_pos;
            return *this;
        }

        constexpr output_t operator*() const {
            return *m_pos;
        }

        container_iter_t m_pos;
    };

    order_by_range( const TPrevRange& prev, TKeySelector key_selector, sort_direction sort_dir )
        : m_prev( prev )
        , m_key_selector( std::move( key_selector ) )
        , m_sort_direction( sort_dir ) {
    }

    constexpr iterator begin() const {
        m_sorted_values.clear();

        for ( const auto& val : m_prev )
            m_sorted_values.push_back( val );

        std::stable_sort(
            m_sorted_values.begin(),
            m_sorted_values.end(),
            [this]( const container_element_t& a, const container_element_t& b ) {
                return compare_keys( a, b );
            } );

        return iterator( m_sorted_values.begin() );
    }

    constexpr iterator end() const {
        return iterator( m_sorted_values.end() );
    }

    constexpr bool compare_keys( const container_element_t& a, const container_element_t& b ) const {
        const auto a_val = m_key_selector( a );
        const auto b_val = m_key_selector( b );

        return m_sort_direction == sort_direction::ascending ? /*ascending:*/ a_val < b_val
                                                             : /*descending:*/ b_val < a_val;
    }

  private:
    TPrevRange          m_prev;
    TKeySelector        m_key_selector;
    sort_direction      m_sort_direction;
    mutable container_t m_sorted_values;
};

// ----------------------------------
// then_by
// ----------------------------------

template <typename TPrevRange, typename TKeySelector>
class then_by_range final
    : public range<then_by_range<TPrevRange, TKeySelector>, typename TPrevRange::iterator::output_t>,
      public sorting_range {
    static_assert(
        std::is_assignable_v<sorting_range, TPrevRange>,
        "A then_by operation can only be appended to another then_by or order_by operation." );

  public:
    using container_element_t = std::decay_t<typename TPrevRange::iterator::output_t>;
    using container_t         = std::vector<container_element_t>;
    using container_iter_t    = typename container_t::const_iterator;

    struct iterator {
        using output_t = typename container_iter_t::reference;

        constexpr explicit iterator( container_iter_t pos )
            : m_pos( pos ) {
        }

        constexpr auto operator==( const iterator& o ) const -> bool {
            return m_pos == o.m_pos;
        }

        constexpr auto operator!=( const iterator& o ) const -> bool {
            return m_pos != o.m_pos;
        }

        constexpr auto operator++() -> iterator& {
            ++m_pos;
            return *this;
        }

        constexpr auto operator*() const -> output_t {
            return *m_pos;
        }

        container_iter_t m_pos;
    };

    constexpr then_by_range( const TPrevRange& prev, TKeySelector key_selector, const sort_direction sort_dir )
        : m_prev( prev )
        , m_key_selector( std::move( key_selector ) )
        , m_sort_direction( sort_dir ) {
    }

    constexpr auto begin() const -> iterator {
        m_sorted_values.clear();

        for ( const auto& val : m_prev )
            m_sorted_values.emplace_back( val );

        std::stable_sort(
            m_sorted_values.begin(),
            m_sorted_values.end(),
            [this]( const container_element_t& a, const container_element_t& b ) {
                return this->compare_keys( a, b );
            } );

        return iterator( m_sorted_values.begin() );
    }

    constexpr auto end() const -> iterator {
        return iterator( m_sorted_values.end() );
    }

    constexpr auto compare_keys( const container_element_t& a, const container_element_t& b ) const -> bool {
        if ( m_prev.compare_keys( a, b ) )
            return true;

        if ( m_prev.compare_keys( b, a ) )
            return false;

        const auto a_value = m_key_selector( a );
        const auto b_value = m_key_selector( b );

        LINQ_ASSERT(
            ( m_sort_direction == sort_direction::ascending || m_sort_direction == sort_direction::descending ) &&
            "invalid sort direction" );

        return m_sort_direction == sort_direction::ascending ? a_value < b_value : b_value < a_value;
    }

  private:
    TPrevRange          m_prev;
    TKeySelector        m_key_selector;
    sort_direction      m_sort_direction;
    mutable container_t m_sorted_values;
};

// ----------------------------------
// container_range
// ----------------------------------

template <typename TContainer>
class container_range final : public range<container_range<TContainer>, typename TContainer::value_type> {
  public:
    struct iterator {
        using container_iter_t = typename TContainer::const_iterator;
        using output_t         = typename TContainer::const_reference;

        constexpr iterator() = default;

        constexpr explicit iterator( container_iter_t pos )
            : m_pos( pos ) {
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_pos == o.m_pos;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_pos != o.m_pos;
        }

        constexpr iterator& operator++() {
            ++m_pos;
            return *this;
        }

        constexpr output_t operator*() const {
            return *m_pos;
        }

        container_iter_t m_pos{};
    };

    constexpr container_range() = default;

    constexpr explicit container_range( const TContainer* container )
        : m_container( container ) {
        LINQ_ASSERT( container != nullptr && "null container given to range" );
    }

    constexpr auto begin() const -> iterator {
        return iterator( m_container->cbegin() );
    }

    constexpr auto end() const -> iterator {
        return iterator( m_container->cend() );
    }

    constexpr auto size() const -> size_t {
        return m_container->size();
    }

  private:
    const TContainer* m_container{};
};

// ----------------------------------
// mutable_container_range
// ----------------------------------

template <typename TContainer>
class mutable_container_range final
    : public range<mutable_container_range<TContainer>, typename TContainer::value_type> {
  public:
    struct iterator {
        using container_iter_t = typename TContainer::iterator;
        using output_t         = typename TContainer::reference;

        constexpr explicit iterator( container_iter_t pos )
            : m_pos( pos ) {
        }

        constexpr auto operator==( const iterator& o ) const -> bool {
            return m_pos == o.m_pos;
        }

        constexpr auto operator!=( const iterator& o ) const -> bool {
            return m_pos != o.m_pos;
        }

        constexpr auto operator++() -> iterator& {
            ++m_pos;
            return *this;
        }

        constexpr auto operator*() const -> output_t& {
            return *m_pos;
        }

        container_iter_t m_pos;
    };

    constexpr explicit mutable_container_range( TContainer* container )
        : m_container( container ) {
        LINQ_ASSERT( container != nullptr && "null container given to range" );
    }

    constexpr auto begin() const -> iterator {
        return iterator( m_container->begin() );
    }

    constexpr auto end() const -> iterator {
        return iterator( m_container->end() );
    }

    constexpr auto size() const -> size_t {
        return m_container->size();
    }

  private:
    TContainer* m_container{};
};

// ----------------------------------
// container_copy_range
// ----------------------------------

template <typename TContainer>
class container_copy_range final : public range<container_copy_range<TContainer>, typename TContainer::value_type> {
  public:
    struct iterator {
        using container_iter_t = typename TContainer::iterator;
        using output_t         = typename TContainer::reference;

        constexpr explicit iterator( container_iter_t pos )
            : m_pos( pos ) {
        }

        constexpr auto operator==( const iterator& o ) const -> bool {
            return m_pos == o.m_pos;
        }

        constexpr auto operator!=( const iterator& o ) const -> bool {
            return m_pos != o.m_pos;
        }

        constexpr auto operator++() -> iterator& {
            ++m_pos;
            return *this;
        }

        constexpr auto operator*() const -> output_t& {
            return *m_pos;
        }

        container_iter_t m_pos;
    };

    constexpr explicit container_copy_range( const TContainer& container )
        : m_container( container ) {
    }

    constexpr iterator begin() const {
        return iterator{ m_container.begin() };
    }

    constexpr iterator end() const {
        return iterator{ m_container.end() };
    }

    constexpr auto size() const {
        return m_container->size();
    }

  private:
    TContainer m_container{};
};

// ----------------------------------
// from_initializer_list
// ----------------------------------

template <typename T, typename TContainer = std::vector<T>>
class initializer_list_range final : public range<initializer_list_range<T>, typename TContainer::const_iterator> {
  public:
    struct iterator {
        using container_iter_t = typename TContainer::const_iterator;
        using output_t         = typename TContainer::const_reference;

        constexpr explicit iterator( container_iter_t pos )
            : m_pos( pos ) {
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_pos == o.m_pos;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_pos != o.m_pos;
        }

        constexpr iterator& operator++() {
            ++m_pos;
            return *this;
        }

        constexpr const output_t& operator*() const {
            return *m_pos;
        }

        container_iter_t m_pos;
    };

    constexpr explicit initializer_list_range( std::initializer_list<T> list ) // NOLINT(*-explicit-constructor)
        : m_list( list.begin(), list.end() ) {
    }

    constexpr iterator begin() const {
        return iterator( m_list.begin() );
    }

    constexpr iterator end() const {
        return iterator( m_list.end() );
    }

    constexpr auto size() const -> size_t {
        return m_list.size();
    }

  private:
    std::vector<T> m_list{};
};

// ----------------------------------
// from_to_range
// ----------------------------------

template <typename T>
class from_to_range final : public range<from_to_range<T>, T> {
  public:
    struct iterator {
        using output_t = T;

        constexpr iterator( output_t value, const output_t* step )
            : m_value( std::move( value ) )
            , m_step( step ) {
        }

        constexpr bool operator==( const iterator& o ) const {
            return o.m_value < m_value;
        }

        constexpr bool operator!=( const iterator& o ) const {
#ifdef __clang__
#pragma clang diagnostic push
#pragma ide diagnostic ignored "Simplify"
#endif
            return !( *this == o );
#ifdef __clang__
#pragma clang diagnostic pop
#endif
        }

        constexpr iterator& operator++() {
            m_value += *m_step;
            return *this;
        }

        constexpr const output_t& operator*() const {
            return m_value;
        }

        output_t        m_value;
        const output_t* m_step;
    };

    constexpr from_to_range( T&& start, T&& end, T&& step )
        : m_start( std::forward<T>( start ) )
        , m_end( std::forward<T>( end ) )
        , m_step( std::forward<T>( step ) ) {
        LINQ_ASSERT( m_start < m_end );
    }

    constexpr iterator begin() const {
        return iterator( m_start, std::addressof( m_step ) );
    }

    constexpr iterator end() const {
        return iterator( m_end, std::addressof( m_step ) );
    }

    constexpr auto size() const -> size_t
#ifdef __cpp_lib_concepts
        requires( std::integral<T> )
#endif
    {
#ifndef __cpp_lib_concepts
        static_assert( std::is_integral_v<T>, "from_to ranges only support .size() for integral elements" );
#endif

        return static_cast<size_t>( ( ( m_end - m_start ) / m_step ) + 1 );
    }

  private:
    T m_start;
    T m_end;
    T m_step;
};

// ----------------------------------
// generate_range
// ----------------------------------

struct generator_return_value_ident {
    /* Nothing to define here. */
};

template <typename T>
struct generator_return_value final : generator_return_value_ident {
    using value_type = T;

    constexpr generator_return_value() = default;

    constexpr explicit generator_return_value( T value )
        : m_value( std::move( value ) )
        , m_is_empty( false ) {
    }

    constexpr bool operator==( const generator_return_value& o ) const {
        // We only care about whether two generator_return_values are empty or not.
        // If the iterator has an empty one, it will match the one from the last
        // iterator, which indicates the end of iteration.
        return m_is_empty == o.m_is_empty;
    }

    constexpr bool operator!=( const generator_return_value& o ) const {
        // Same as in operator==.
        return m_is_empty != o.m_is_empty;
    }

    T    m_value{};
    bool m_is_empty{ true };
};

template <typename TGenerator>
struct generate_range_traits final {
    using generator_return_type = std::invoke_result_t<TGenerator, size_t>;

    // Ensure that whatever the generator returned is indeed of type generator_return_type.
    static_assert(
        std::is_base_of_v<generator_return_value_ident, generator_return_type>,
        "The generator function is expected to return a result of linq::generate_return() or "
        "linq::generate_finish()." );

    // The type that is wrapped by the returned generator_return_type.
    using value_type = typename generator_return_type::value_type;
};

template <typename TGenerator>
class generator_range final
    : public range<generator_range<TGenerator>, typename generate_range_traits<TGenerator>::value_type> {
  public:
    struct iterator {
        using generator_return_type = typename generate_range_traits<TGenerator>::generator_return_type;
        using output_t              = typename generate_range_traits<TGenerator>::value_type;

        constexpr iterator( const generator_range* parent, bool is_end )
            : m_parent( parent ) {
            if ( is_end ) {
                m_last_result = generator_return_type();
            }
            else {
                // First iteration
                m_last_result = m_parent->m_generator( m_iteration );
            }
        }

        constexpr bool operator==( const iterator& o ) const {
            return m_last_result == o.m_last_result;
        }

        constexpr bool operator!=( const iterator& o ) const {
            return m_last_result != o.m_last_result;
        }

        constexpr iterator& operator++() {
            ++m_iteration;
            m_last_result = m_parent->m_generator( m_iteration );
            return *this;
        }

        constexpr const output_t& operator*() const {
            return m_last_result.m_value;
        }

        const generator_range* m_parent;
        size_t                 m_iteration{};
        generator_return_type  m_last_result;
    };

    constexpr explicit generator_range( TGenerator generator )
        : m_generator( std::move( generator ) ) {
    }

    constexpr iterator begin() const {
        return iterator( this, false );
    }

    constexpr iterator end() const {
        return iterator( this, true );
    }

  private:
    TGenerator m_generator;
};

// ----------------------------------
// base_range method definitions
// ----------------------------------

template <typename Derived, typename TOutput>
template <typename TPredicate>
constexpr auto range<Derived, TOutput>::where( TPredicate&& predicate ) const {
    return where_range<Derived, TPredicate>( self_ref(), std::forward<TPredicate>( predicate ) );
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::distinct() const {
    return distinct_range<Derived>( self_ref() );
}

template <typename Derived, typename TOutput>
template <typename TTransform>
constexpr auto range<Derived, TOutput>::select( TTransform&& transform ) const {
    return select_range<Derived, TTransform>( self_ref(), std::forward<TTransform>( transform ) );
}

template <typename Derived, typename TOutput>
#ifdef LINQ_NO_STL_CONTAINERS
template <typename StringType>
#endif
[[nodiscard]]
constexpr auto range<Derived, TOutput>::select_to_string( int int_base, std::chars_format float_format ) const {
#ifndef LINQ_NO_STL_CONTAINERS
    using StringType = std::string;
#endif

    return select_to_string_range<Derived, StringType>( self_ref(), int_base, float_format );
}

template <typename Derived, typename TOutput>
template <typename TTransform>
constexpr auto range<Derived, TOutput>::select_many( TTransform&& transform ) const {
    return select_many_range<Derived, TTransform>( self_ref(), std::forward<TTransform>( transform ) );
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::reverse() const {
    return reverse_range<Derived>( self_ref() );
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::take( size_t count ) const {
    return take_range<Derived>( self_ref(), count );
}

template <typename Derived, typename TOutput>
template <typename TPredicate>
constexpr auto range<Derived, TOutput>::take_while( TPredicate&& predicate ) const {
    return take_while_range<Derived, TPredicate>( self_ref(), std::forward<TPredicate>( predicate ) );
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::skip( size_t count ) const {
    return skip_range<Derived>( self_ref(), count );
}

template <typename Derived, typename TOutput>
template <typename TPredicate>
constexpr auto range<Derived, TOutput>::skip_while( TPredicate&& predicate ) const {
    return skip_while_range<Derived, TPredicate>( self_ref(), std::forward<TPredicate>( predicate ) );
}

template <typename Derived, typename TOutput>
template <typename TOtherRange>
constexpr auto range<Derived, TOutput>::append( const TOtherRange& other_range ) const {
    return append_range<Derived, TOtherRange>( self_ref(), other_range );
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::repeat( size_t count ) const {
    return repeat_range<Derived>( self_ref(), count );
}

template <typename Derived, typename TOutput>
template <typename TOtherRange, typename TKeySelectorA, typename TKeySelectorB, typename TTransform>
constexpr auto range<Derived, TOutput>::join(
    const TOtherRange& other_range,
    TKeySelectorA&&    key_selector_a,
    TKeySelectorB&&    key_selector_b,
    TTransform&&       transform ) const {
    return join_range<Derived, TOtherRange, TKeySelectorA, TKeySelectorB, TTransform>(
        self_ref(),
        other_range,
        std::forward<TKeySelectorA>( key_selector_a ),
        std::forward<TKeySelectorB>( key_selector_b ),
        std::forward<TTransform>( transform ) );
}

template <typename Derived, typename TOutput>
template <typename TKeySelector>
constexpr auto range<Derived, TOutput>::order_by( TKeySelector&& key_selector, sort_direction sort_dir ) const {
    return order_by_range<Derived, TKeySelector>( self_ref(), std::forward<TKeySelector>( key_selector ), sort_dir );
}

template <typename Derived, typename TOutput>
template <typename TKeySelector>
constexpr auto range<Derived, TOutput>::order_by_descending( TKeySelector&& key_selector ) const {
    return order_by<TKeySelector>( std::forward<TKeySelector>( key_selector ), sort_direction::descending );
}

template <typename Derived, typename TOutput>
template <typename TKeySelector>
constexpr auto range<Derived, TOutput>::then_by( TKeySelector&& key_selector, sort_direction sort_dir ) const {
    return then_by_range<Derived, TKeySelector>( self_ref(), std::forward<TKeySelector>( key_selector ), sort_dir );
}

template <typename Derived, typename TOutput>
template <typename TKeySelector>
constexpr auto range<Derived, TOutput>::order_by_ascending( TKeySelector&& key_selector ) const {
    return order_by<TKeySelector>( std::forward<TKeySelector>( key_selector ), sort_direction::ascending );
}

template <typename Derived, typename TOutput>
template <typename TKeySelector>
constexpr auto range<Derived, TOutput>::then_by_ascending( TKeySelector&& key_selector ) const {
    return then_by<TKeySelector>( std::forward<TKeySelector>( key_selector ), sort_direction::ascending );
}

template <typename Derived, typename TOutput>
template <typename TKeySelector>
constexpr auto range<Derived, TOutput>::then_by_descending( TKeySelector&& key_selector ) const {
    return then_by<TKeySelector>( std::forward<TKeySelector>( key_selector ), sort_direction::descending );
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::sum() const {
    static_assert(
        std::is_default_constructible_v<output_t>,
        "sum() requires the range's output type to be default-constructible." );

    auto first  = true;
    auto result = output_t();

    for ( auto&& p : self_ref() ) {
        if ( first ) {
            result = p;
            first  = false;
        }
        else {
            result += p;
        }
    }

    return first ? std::optional<output_t>() : std::optional<output_t>( std::move( result ) );
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::min() const {
    static_assert(
        std::is_default_constructible_v<output_t>,
        "min() requires the range's output type to be default-constructible." );

    auto first  = true;
    auto result = output_t();

    for ( auto&& p : self_ref() ) {
        if ( first ) {
            result = std::move( p );
            first  = false;
        }
        else if ( p < result ) {
            result = p;
        }
    }

    return first ? std::optional<output_t>{} : std::optional<output_t>{ result };
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::max() const {
    static_assert(
        std::is_default_constructible_v<output_t>,
        "max() requires the range's output type to be default-constructible." );

    auto first  = true;
    auto result = output_t();

    for ( auto&& p : self_ref() ) {
        if ( first ) {
            result = std::move( p );
            first  = false;
        }
        else if ( result < p ) {
            result = p;
        }
    }

    return first ? std::optional<output_t>{} : std::optional<output_t>{ result };
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::sum_and_count() const {
    static_assert(
        std::is_default_constructible_v<output_t>,
        "sum_and_count() requires the range's output type to be default-constructible." );

    auto first  = true;
    auto result = output_t();
    auto count  = static_cast<size_t>( 0 );

    for ( auto&& p : self_ref() ) {
        if ( first ) {
            result = std::move( p );
            first  = false;
        }
        else {
            result += p;
        }
        ++count;
    }

    return first ? std::optional<std::pair<output_t, size_t>>()
                 : std::optional<std::pair<output_t, size_t>>( std::make_pair( std::move( result ), count ) );
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::average() const
#ifdef __cpp_lib_concepts
    requires( averageable<output_t> )
#endif
{
    return calculate_average<output_t>( self_ref() );
}

template <typename Derived, typename TOutput>
#ifdef __cpp_lib_concepts
template <typename TSeed, std::invocable<TSeed&&, const TOutput&> TAccumFunc>
#else
template <typename TSeed, typename TAccumFunc>
#endif
constexpr auto range<Derived, TOutput>::aggregate( TSeed seed, TAccumFunc&& func ) const {
    static_assert( std::is_move_assignable_v<TSeed>, "aggregate() requires TSeed to be move-constructible." );

    auto result = std::move( seed );

    for ( auto&& p : self_ref() ) {
        result = std::invoke( func, std::move( result ), p );
    }

    return result;
}

template <typename Derived, typename TOutput>
#ifdef __cpp_lib_concepts
template <std::invocable<TOutput&&, const TOutput&> TAccumFunc>
#else
template <typename TAccumFunc>
#endif
[[nodiscard]]
constexpr auto range<Derived, TOutput>::reduce( const TAccumFunc& func ) const {
    static_assert(
        std::is_default_constructible_v<output_t>,
        "reduce() requires the range's output type to be default-constructible." );

    static_assert(
        std::is_move_assignable_v<output_t>,
        "reduce() requires the range's output type to be move-constructible." );

    auto result = output_t();

    for ( auto first = true; auto&& p : self_ref() ) {
        if ( first ) {
            result = std::move( p );
            first  = false;
        }
        else {
            result = func( std::move( result ), p );
        }
    }

    return result;
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::first() const -> std::optional<output_t> {
    for ( auto&& p : self_ref() )
        return std::optional( std::move( p ) );

    return {};
}

template <typename Derived, typename TOutput>
template <typename TPredicate>
constexpr auto range<Derived, TOutput>::first( const TPredicate& predicate ) const -> std::optional<output_t> {
    for ( auto&& p : self_ref() ) {
        if ( std::invoke( predicate, p ) )
            return std::optional( std::move( p ) );
    }

    return {};
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::last() const -> std::optional<output_t> {
    auto have_any = false;
    auto result   = output_t();

    for ( auto&& p : self_ref() ) {
        result   = std::move( p );
        have_any = true;
    }

    return have_any ? std::optional( std::move( result ) ) : std::optional<output_t>();
}

template <typename Derived, typename TOutput>
template <typename TPredicate>
constexpr auto range<Derived, TOutput>::last( const TPredicate& predicate ) const -> std::optional<output_t> {
    bool     have_any = false;
    output_t ret{};

    for ( const auto& p : static_cast<const Derived&>( *this ) ) {
        if ( std::invoke( predicate, p ) ) {
            ret      = p;
            have_any = true;
        }
    }

    return have_any ? std::optional{ ret } : std::optional<output_t>{};
}

template <typename Derived, typename TOutput>
template <typename TPredicate>
constexpr auto range<Derived, TOutput>::any( const TPredicate& predicate ) const -> bool {
    for ( const auto& p : static_cast<const Derived&>( *this ) ) {
        if ( std::invoke( predicate, p ) )
            return true;
    }

    return false;
}

template <typename Derived, typename TOutput>
template <typename TPredicate>
constexpr auto range<Derived, TOutput>::all( const TPredicate& predicate ) const -> bool {
    for ( const auto& p : static_cast<const Derived&>( *this ) ) {
        if ( !std::invoke( predicate, p ) )
            return false;
    }

    return true;
}

template <typename Derived, typename TOutput>
template <typename TPredicate>
constexpr bool range<Derived, TOutput>::none( const TPredicate& predicate ) const {
    bool any_elements = false;
    bool any_none     = false;

    for ( const auto& p : static_cast<const Derived&>( *this ) ) {
        any_elements = true;

        if ( !std::invoke( predicate, p ) ) {
            any_none = true;
            break;
        }
    }

    return !any_elements || any_none;
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::count() const -> size_t {
    size_t ret{ 0 };

    for ( const auto& p : static_cast<const Derived&>( *this ) ) {
        std::ignore = p;
        ++ret;
    }

    return ret;
}

template <typename Derived, typename TOutput>
template <typename TPredicate>
constexpr auto range<Derived, TOutput>::count( const TPredicate& predicate ) const -> size_t {
    size_t ret{ 0 };

    for ( const auto& p : static_cast<const Derived&>( *this ) ) {
        if ( std::invoke( predicate, p ) )
            ++ret;
    }

    return ret;
}

template <typename Derived, typename TOutput>
constexpr std::optional<typename range<Derived, TOutput>::output_t>
range<Derived, TOutput>::element_at( size_t index ) const {
    size_t i{ 0 };

    for ( const auto& p : static_cast<const Derived&>( *this ) ) {
        if ( i >= index ) {
            return std::optional{ p };
        }

        ++i;
    }

    return {};
}

template <typename Derived, typename TOutput>
template <typename U>
constexpr auto range<Derived, TOutput>::equals( const range<U, TOutput>& other_range ) const -> bool {
    // const auto& me = static_cast<const Derived&>( *this );
    // return ranges_equal( me.begin(), me.end(), other_range.begin(), other_range.end() );
    return false;
}

template <typename Derived, typename TOutput>
constexpr auto range<Derived, TOutput>::equals( const std::initializer_list<TOutput>& list ) const -> bool {
    const auto& me         = self_ref();
    const auto  my_size    = get_range_size( me );
    const auto  other_size = list.size();

    if ( my_size != other_size )
        return false;

    auto it = me.begin();

    for ( const auto& element : list ) {
        if ( !( *it == element ) )
            return false;

        ++it;
    }

    return true;
}

#ifndef LINQ_NO_STL_CONTAINERS

template <typename Derived, typename TOutput>
auto range<Derived, TOutput>::to_vector() const -> std::vector<output_t> {
    const auto& me = static_cast<const Derived&>( *this );

    auto vec = std::vector<output_t>();

    if constexpr ( has_fixed_size<Derived> )
        vec.reserve( me.size() );

    for ( auto&& p : static_cast<const Derived&>( *this ) )
        vec.emplace_back( std::move( p ) );

    return vec;
}

template <typename Derived, typename TOutput>
auto range<Derived, TOutput>::to_map() const
#ifdef __cpp_lib_concepts
    requires( has_first_and_second_type<output_t> )
#endif
{
    using FirstType  = typename output_t::first_type;
    using SecondType = typename output_t::second_type;

    auto map = std::map<FirstType, SecondType>();

    for ( auto&& [first, second] : static_cast<const Derived&>( *this ) )
        map.emplace( std::move( first ), std::move( second ) );

    return map;
}

template <typename Derived, typename TOutput>
auto range<Derived, TOutput>::to_unordered_map() const
#ifdef __cpp_lib_concepts
    requires( has_first_and_second_type<output_t> )
#endif
{
    using FirstType  = typename output_t::first_type;
    using SecondType = typename output_t::second_type;

    auto map = std::unordered_map<FirstType, SecondType>();

    for ( auto&& [first, second] : static_cast<const Derived&>( *this ) )
        map.emplace( std::move( first ), std::move( second ) );

    return map;
}

#endif // LINQ_NO_STL_CONTAINERS
} // end namespace details

// from()

/// @brief Creates a non-owning range that references an immutable container.
/// Subsequent operations of this range will produce immutable items.
///
/// @tparam C The type of container to reference
/// @tparam T The type of a value inside the container
/// @tparam A The allocator type of the container
/// @param container The container to reference
/// @return A range to be used for subsequent operations
///
/// Example:
/// @code{.cpp}
/// const auto numbers = std::vector{1,2,3};
/// auto query = linq::from(&numbers);
/// for (const auto& value : query) {
///   // ...
/// }
/// @endcode
template <template <typename, typename> typename C, typename T, typename A>
[[nodiscard]]
static constexpr auto from( const C<T, A>* container ) {
    return details::container_range<C<T, A>>{ container };
}

// std::set

template <template <typename, typename, typename> typename C, typename T, typename S, typename U>
[[nodiscard]]
static constexpr auto from( const C<T, S, U>* container ) {
    return details::container_range<C<T, S, U>>{ container };
}

// std::array

template <template <class, size_t> class C, typename T, size_t L>
[[nodiscard]]
static constexpr auto from( const C<T, L>* container ) {
    return details::container_range<C<T, L>>( container );
}

// std::map

template <template <class, class, class, class> class C, typename K, typename T, typename S, typename U>
[[nodiscard]]
static constexpr auto from( const C<K, T, S, U>* container ) {
    return details::container_range<C<K, T, S, U>>( container );
}

// misc container

template <template <typename> typename C, class T>
[[nodiscard]]
static constexpr auto from( const C<T>* container ) {
    return details::container_range<C<T>>( container );
}

// from_mutable()

// std::vector, std::list, std::dequeue, ...

template <template <typename, typename> typename C, typename T, typename A>
[[nodiscard]]
static constexpr auto from_mutable( C<T, A>* container ) {
    return details::mutable_container_range<C<T, A>>( container );
}

// std::set

template <template <typename, typename, typename> typename C, typename T, typename S, typename U>
[[nodiscard]]
static constexpr auto from_mutable( C<T, S, U>* container ) {
    return details::mutable_container_range<C<T, S, U>>( container );
}

// std::array

template <template <class, size_t> class C, typename T, size_t L>
[[nodiscard]]
static constexpr auto from_mutable( C<T, L>* container ) {
    return details::mutable_container_range<C<T, L>>( container );
}

// std::map

template <template <class, class, class, class> class C, typename K, typename T, typename S, typename U>
[[nodiscard]]
static constexpr auto from_mutable( C<K, T, S, U>* container ) {
    return details::mutable_container_range<C<K, T, S, U>>( container );
}

// misc container

template <template <typename> typename C, class T>
[[nodiscard]]
static constexpr auto from_mutable( C<T>* container ) {
    return details::mutable_container_range<C<T>>( container );
}

template <typename TContainer>
[[nodiscard]]
static constexpr auto from_copy( const TContainer& container ) {
    return details::container_copy_range<TContainer>( container );
}

template <typename T>
[[nodiscard]]
static constexpr auto from( std::initializer_list<T> list ) {
    return details::initializer_list_range<T>( list );
}

template <typename T>
#ifdef __cpp_lib_concepts
    requires( details::addable<T> )
#endif
[[nodiscard]]
static constexpr auto from_to( T&& start, T&& end, T&& step = T( 1 ) ) {
    return details::from_to_range<T>( std::forward<T>( start ), std::forward<T>( end ), std::forward<T>( step ) );
}

template <typename TGenerator>
[[nodiscard]]
static constexpr auto generate( TGenerator&& generator ) -> details::generator_range<TGenerator> {
    return details::generator_range<TGenerator>{ std::forward<TGenerator>( generator ) };
}

template <typename T>
[[nodiscard]]
static constexpr auto generate_return( T&& value ) -> details::generator_return_value<T> {
    return details::generator_return_value{ std::forward<T>( value ) };
}

template <typename T>
[[nodiscard]]
static constexpr auto generate_finish() -> details::generator_return_value<T> {
    return {};
}

/// Returns the .size() of a value
static constexpr auto size = []( const auto& value ) {
    return value.size();
};

// ReSharper disable once CppUseFamiliarTemplateSyntaxForGenericLambdas
/// Returns a value exactly as it was passed in.
static constexpr auto self = []( auto&& value ) {
    return std::forward<decltype( value )>( value );
};
} // end namespace linq

#endif
